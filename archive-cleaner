#!/usr/bin/env python

from glob import glob
from re import search
from re import finditer
from os.path import basename
from os.path import isfile
from os.path import join
from sys import stderr
from multiprocessing import Pool

from libarchive import file_reader

ARCHS = ['x86_64']
PKGEXT = '.tar.xz'
ARCHIVE_DIR = '/srv/archive'
SOURCE_DIR = '/srv/ftp'
SOURCE_WHITELIST = ['core', 'extra', 'staging', 'testing', 'community', 'community-staging', 'community-testing', 'multilib', 'multilib-staging', 'multilib-testing', 'gnome-unstable', 'kde-unstable']


def read_file(filename, arch):
    packages = []
    with file_reader(filename) as archive:
        for entry in archive:
            if entry.name == '.BUILDINFO':
                packages.extend(get_packages_from_buildinfo(filename, entry, arch))
                break
    if not packages:
        print(f'WARNING: .BUILDINFO not found in package {filename}', file=stderr)
    packages.append(basename(filename))
    return packages


def get_packages_from_buildinfo(filename, archive_entry, arch):
    buildinfo = b''.join(archive_entry.get_blocks()).decode()
    m = search('format = (\\d)', buildinfo)
    buildinfo_format = 0 if not m else int(m.group(1))
    installed = [m.group(1) for m in finditer(r'installed = (.+)', buildinfo)]
    print(f'INFO: found .BUILDINFO format {buildinfo_format} with {len(installed)} installed packages for {filename}', file=stderr)
    packages = []
    if buildinfo_format > 0:
        for package in installed:
            pkgfilename = f'{package}.pkg.tar.xz'
            m = search('^(.+)-(\\d+)?:?([\\w\\d\\.+~]+)-([\\d\\.]+)-(\\w+)$', package)
            if not m:
                print(f'ERROR: failed to parse package label {package} for {filename}', file=stderr)
                continue
            pkgname = m.group(1)
            directory = join(ARCHIVE_DIR, 'packages', pkgname[0], pkgname)
            path = join(directory, pkgfilename)
            if not isfile(path):
                print(f'ERROR: {package} needed for {filename} not in archive {path}', file=stderr)
                continue
            packages.append(pkgfilename)
        return packages
    for package in installed:
        filename_any = f'{package}-any.pkg.tar.xz'
        filename_arch = f'{package}-{arch}.pkg.tar.xz'
        m = search('^(.+)-(\\d+)?:?([\\w\\d\\.+~]+)-([\\d\\.]+)$', package)
        if not m:
            print(f'ERROR: failed to parse package label {package} for {filename}', file=stderr)
            continue
        pkgname = m.group(1)
        directory = join(ARCHIVE_DIR, 'packages', pkgname[0], pkgname)
        path_any = join(directory, filename_any)
        path_arch = join(directory, filename_arch)
        if isfile(path_any):
            packages.append(filename_any)
        elif isfile(path_arch):
            packages.append(filename_arch)
        else:
            print(f'ERROR: {package} needed for {filename} not in archive {path_any}', file=stderr)
            print(f'ERROR: {package} needed for {filename} not in archive {path_arch}', file=stderr)
    return packages


def main():
    tasks = []
    needed = set()
    for subdir in SOURCE_WHITELIST:
        for arch in ARCHS:
            directory = join(SOURCE_DIR, subdir, 'os', arch)
            for filename in glob(join(directory, f'*{PKGEXT}')):
                tasks.append((filename, arch))

    with Pool(processes=32) as pool:
        results = pool.starmap(read_file, tasks)

    for result in results:
        needed = needed.union(result)
    print('\n'.join(needed))


if __name__ == '__main__':
    main()
